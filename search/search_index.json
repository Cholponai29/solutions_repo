{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"import numpy as np import matplotlib.pyplot as plt g = 9.81 # gravitational acceleration (m/s^2) def calculate_range(v0, theta_deg, h0=0): \"\"\" Calculate the range of a projectile launched at angle theta_deg with initial speed v0 and initial height h0. \"\"\" theta = np.radians(theta_deg) if h0 == 0: # Simplified range formula when launch height is 0 R = (v0**2 * np.sin(2 * theta)) / g else: # Generalized formula considering launch height h0 R = (v0 * np.cos(theta)) * ( v0 * np.sin(theta) + np.sqrt((v0 * np.sin(theta))**2 + 2 * g * h0) ) / g return R v0_values = [10, 20, 30] # different initial velocities angles = np.linspace(0, 90, 500) plt.figure(figsize=(10, 6)) for v0 in v0_values: ranges = [calculate_range(v0, angle) for angle in angles] plt.plot(angles, ranges, label=f'v\u2080 = {v0} m/s') plt.title('Projectile Range vs Launch Angle') plt.xlabel('Launch Angle (degrees)') plt.ylabel('Range (m)') plt.legend() plt.grid(True) plt.tight_layout() plt.show() \"a problem1\")","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # System Parameters gamma = 0.2 # Damping coefficient omega0 = 1.0 # Natural frequency of the pendulum A = 1.2 # Amplitude of the external driving force omega_d = 2/3 # Driving frequency # Time span for simulation t_max = 100 t_points = np.linspace(0, t_max, 10000) # Differential equations for the forced damped pendulum def forced_damped_pendulum(t, y): theta, omega = y dtheta_dt = omega domega_dt = -gamma * omega - omega0**2 * np.sin(theta) + A * np.cos(omega_d * t) return [dtheta_dt, domega_dt] # Initial conditions: [angle, angular velocity] y0 = [0.2, 0.0] # Solve the system using Runge-Kutta method solution = solve_ivp(forced_damped_pendulum, [0, t_max], y0, t_eval=t_points, method='RK45') # Extract solution theta = solution.y[0] omega = solution.y[1] time = solution.t # Normalize angle to be within (-\u03c0, \u03c0) for better visualization theta_mod = ((theta + np.pi) % (2 * np.pi)) - np.pi # Plot: Angle over time plt.figure(figsize=(10, 4)) plt.plot(time, theta_mod) plt.xlabel('Time (s)') plt.ylabel('Angle \u03b8 (rad)') plt.title('Forced Damped Pendulum: Angle over Time') plt.grid(True) plt.tight_layout() plt.show() # Plot: Phase portrait (\u03b8 vs \u03c9) plt.figure(figsize=(6, 6)) plt.plot(theta_mod, omega, lw=0.5) plt.xlabel('\u03b8 (rad)') plt.ylabel('\u03c9 (rad/s)') plt.title('Phase Portrait') plt.grid(True) plt.tight_layout() plt.show() # Plot: Poincar\u00e9 section (samples taken once every driving period) T_drive = 2 * np.pi / omega_d poincare_times = np.arange(0, t_max, T_drive) theta_poincare = [] omega_poincare = [] for t_cross in poincare_times: idx = np.searchsorted(time, t_cross) if idx < len(time): theta_poincare.append(theta_mod[idx]) omega_poincare.append(omega[idx]) plt.figure(figsize=(6, 6)) plt.scatter(theta_poincare, omega_poincare, s=5, color='red') plt.xlabel('\u03b8 (rad)') plt.ylabel('\u03c9 (rad/s)') plt.title('Poincar\u00e9 Section') plt.grid(True) plt.tight_layout() plt.show()","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # Mass of Earth (kg) # Generate a range of orbital radii (in meters) radii = np.linspace(7e6, 4.2e7, 100) # from 7,000 km to 42,000 km # Calculate orbital periods for circular orbits def orbital_period(r, M): return 2 * np.pi * np.sqrt(r**3 / (G * M)) periods = orbital_period(radii, M) # Plot T^2 vs r^3 T_squared = periods**2 r_cubed = radii**3 plt.figure(figsize=(8, 5)) plt.plot(r_cubed, T_squared, label=r\"$T^2$ vs $r^3$\", color='navy') plt.xlabel(r\"Orbital Radius Cubed $r^3$ (m$^3$)\") plt.ylabel(r\"Orbital Period Squared $T^2$ (s$^2$)\") plt.title(\"Kepler's Third Law: $T^2 \\propto r^3$\") plt.grid(True) plt.legend() plt.tight_layout() plt.show() # Optional: Show a linear fit to confirm proportionality from scipy.stats import linregress slope, intercept, r_value, *_ = linregress(r_cubed, T_squared) print(f\"Fitted slope (should be ~4\u03c0\u00b2/GM): {slope:.3e}\") print(f\"R\u00b2 value: {r_value**2:.5f} (should be close to 1)\")","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3/kg/s^2) # Celestial body data: name, radius (m), mass (kg) bodies = { \"Earth\": { \"radius\": 6.371e6, \"mass\": 5.972e24 }, \"Mars\": { \"radius\": 3.3895e6, \"mass\": 6.417e23 }, \"Jupiter\": { \"radius\": 6.9911e7, \"mass\": 1.898e27 } } # Functions for cosmic velocities def first_cosmic_velocity(M, R): return np.sqrt(G * M / R) def second_cosmic_velocity(M, R): return np.sqrt(2) * first_cosmic_velocity(M, R) # Third cosmic velocity estimation from Earth def third_cosmic_velocity(M_sun, R_earth_orbit): return np.sqrt(2 * G * M_sun / R_earth_orbit) # Compute and display velocities print(\"Cosmic Velocities (km/s):\\n\") for body, data in bodies.items(): v1 = first_cosmic_velocity(data[\"mass\"], data[\"radius\"]) / 1000 # km/s v2 = second_cosmic_velocity(data[\"mass\"], data[\"radius\"]) / 1000 print(f\"{body}:\") print(f\" 1st Cosmic Velocity: {v1:.2f} km/s\") print(f\" 2nd Cosmic Velocity: {v2:.2f} km/s\") # Estimate 3rd cosmic velocity (from Earth orbit) R_earth_orbit = 1.496e11 # in meters M_sun = 1.989e30 # kg v3 = third_cosmic_velocity(M_sun, R_earth_orbit) / 1000 # km/s print(f\"\\nThird Cosmic Velocity (from Earth orbit): {v3:.2f} km/s\") # Visualization labels = [] v1_vals = [] v2_vals = [] for body, data in bodies.items(): labels.append(body) v1_vals.append(first_cosmic_velocity(data[\"mass\"], data[\"radius\"]) / 1000) v2_vals.append(second_cosmic_velocity(data[\"mass\"], data[\"radius\"]) / 1000) x = np.arange(len(labels)) width = 0.35 plt.figure(figsize=(10, 6)) plt.bar(x - width/2, v1_vals, width, label='1st Cosmic Velocity') plt.bar(x + width/2, v2_vals, width, label='2nd Cosmic Velocity') plt.axhline(v3, color='red', linestyle='--', label='3rd Cosmic Velocity (Sun escape)') plt.xticks(x, labels) plt.ylabel('Velocity (km/s)') plt.title('Cosmic Velocities for Various Celestial Bodies') plt.legend() plt.grid(True, linestyle='--', alpha=0.6) plt.tight_layout() plt.show()","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # m^3/kg/s^2 M = 5.972e24 # kg (mass of Earth) R_earth = 6.371e6 # m (radius of Earth) # Earth's escape velocity at the surface v_escape = np.sqrt(2 * G * M / R_earth) # Initial conditions altitude = 300e3 # 300 km above Earth's surface r0 = R_earth + altitude initial_positions = np.array([r0, 0.0]) # starting at (r0, 0) angles = [0, 45, 90] # in degrees speeds = [7.5e3, v_escape, 12e3] # various initial speeds (m/s) # Time span for simulation t_max = 8000 # seconds t_eval = np.linspace(0, t_max, 10000) def gravity_ode(t, y): rx, ry, vx, vy = y r = np.sqrt(rx**2 + ry**2) ax = -G * M * rx / r**3 ay = -G * M * ry / r**3 return [vx, vy, ax, ay] # Plot setup plt.figure(figsize=(8, 8)) earth = plt.Circle((0, 0), R_earth, color='blue', alpha=0.3, label='Earth') ax = plt.gca() ax.add_patch(earth) # Simulate and plot each trajectory for speed in speeds: for angle_deg in angles: angle_rad = np.radians(angle_deg) vx0 = speed * np.cos(angle_rad) vy0 = speed * np.sin(angle_rad) y0 = [r0, 0, vx0, vy0] sol = solve_ivp(gravity_ode, [0, t_max], y0, t_eval=t_eval, rtol=1e-8) rx, ry = sol.y[0], sol.y[1] # Filter values inside Earth's radius to stop the plot mask = np.sqrt(rx**2 + ry**2) >= R_earth rx, ry = rx[mask], ry[mask] plt.plot(rx, ry, label=f'{speed/1000:.1f} km/s @ {angle_deg}\u00b0') # Plot customization plt.xlabel('x (m)') plt.ylabel('y (m)') plt.title('Payload Trajectories near Earth') plt.axis('equal') plt.legend() plt.grid(True) plt.tight_layout() plt.show()","title":"Problem 3"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"import numpy as np import matplotlib.pyplot as plt # Wave parameters A = 1 # amplitude wavelength = 1.0 # meters frequency = 1.0 # Hz omega = 2 * np.pi * frequency k = 2 * np.pi / wavelength phi = 0 # same phase for all sources # Simulation grid grid_size = 400 x = np.linspace(-5, 5, grid_size) y = np.linspace(-5, 5, grid_size) X, Y = np.meshgrid(x, y) # Polygon setup def generate_polygon_vertices(sides, radius): angles = np.linspace(0, 2*np.pi, sides, endpoint=False) return np.stack([radius * np.cos(angles), radius * np.sin(angles)], axis=1) # Choose polygon type polygon_sides = 5 # Try 3 for triangle, 4 for square, etc. radius = 2.5 sources = generate_polygon_vertices(polygon_sides, radius) # Time snapshot t = 0 # try different values for animation # Superposition of waves U = np.zeros_like(X) for x0, y0 in sources: R = np.sqrt((X - x0)**2 + (Y - y0)**2) U += A * np.cos(k * R - omega * t + phi) # Plotting the interference pattern plt.figure(figsize=(8, 8)) plt.pcolormesh(X, Y, U, shading='auto', cmap='RdBu') plt.colorbar(label='Wave Displacement') plt.scatter(sources[:, 0], sources[:, 1], color='black', label='Sources') plt.title(f'Wave Interference from {polygon_sides} Sources (Regular Polygon)') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.axis('equal') plt.legend() plt.grid(False) plt.tight_layout() plt.show()","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants and initial conditions q = 1.6e-19 # Charge of the particle (C) m = 9.11e-31 # Mass of the particle (kg) E = np.array([0, 0, 0]) # Electric field (V/m), zero in simple cases B = np.array([0, 0, 1]) # Magnetic field (T), aligned with the z-axis v0 = np.array([1e5, 0, 0]) # Initial velocity (m/s) r0 = np.array([0, 0, 0]) # Initial position (m) dt = 1e-9 # Time step (s) t_max = 1e-6 # Total simulation time (s) # Time array t = np.arange(0, t_max, dt) # Initialize arrays to store particle's position and velocity r = np.zeros((len(t), 3)) # Position (x, y, z) v = np.zeros((len(t), 3)) # Velocity (vx, vy, vz) r[0] = r0 v[0] = v0 # Simulation loop for i in range(1, len(t)): # Calculate Lorentz force F = q * (E + np.cross(v[i-1], B)) # Update velocity and position using Euler's method a = F / m v[i] = v[i-1] + a * dt r[i] = r[i-1] + v[i-1] * dt # Plot the trajectory in 3D space fig = plt.figure() ax = fig.add_subplot(111, projection='3d') ax.plot(r[:, 0], r[:, 1], r[:, 2], label=\"Particle trajectory\") ax.set_xlabel('X') ax.set_ylabel('Y') ax.set_zlabel('Z') ax.set_title('Particle Trajectory in Uniform Magnetic Field') plt.show()","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"import numpy as np import matplotlib.pyplot as plt import seaborn as sns # Set random seed for reproducibility np.random.seed(42) # Parameters population_size = 100000 # Population size for each distribution sample_sizes = [5, 10, 30, 50] # Sample sizes for sampling distribution n_samples = 1000 # Number of samples to take for each sample size # Simulate populations uniform_population = np.random.uniform(0, 1, population_size) exponential_population = np.random.exponential(scale=1, size=population_size) binomial_population = np.random.binomial(n=10, p=0.5, size=population_size) # Function to create sample means for different sample sizes def sample_means(population, sample_size, n_samples): means = [] for _ in range(n_samples): sample = np.random.choice(population, size=sample_size, replace=True) means.append(np.mean(sample)) return means # Plotting function for histograms def plot_sampling_distribution(population, dist_name, sample_sizes, n_samples): plt.figure(figsize=(14, 10)) for i, sample_size in enumerate(sample_sizes, 1): sample_mean_dist = sample_means(population, sample_size, n_samples) plt.subplot(2, 2, i) sns.histplot(sample_mean_dist, kde=True, stat='density', bins=30) plt.title(f'{dist_name} Distribution\\nSample Size = {sample_size}') plt.xlabel('Sample Mean') plt.ylabel('Density') plt.tight_layout() plt.show() # Plot sampling distributions for all types of populations plot_sampling_distribution(uniform_population, 'Uniform', sample_sizes, n_samples) plot_sampling_distribution(exponential_population, 'Exponential', sample_sizes, n_samples) plot_sampling_distribution(binomial_population, 'Binomial', sample_sizes, n_samples)","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"import numpy as np import matplotlib.pyplot as plt # Part 1: Circle-based Monte Carlo Method def estimate_pi_circle(n_points): # Generate random points in the square (-1, 1) x = np.random.uniform(-1, 1, n_points) y = np.random.uniform(-1, 1, n_points) # Count how many points fall inside the unit circle inside_circle = (x**2 + y**2) <= 1 # Estimate pi pi_estimate = 4 * np.sum(inside_circle) / n_points return pi_estimate, x, y, inside_circle # Part 2: Buffon's Needle Method def estimate_pi_buffon(needle_length, line_spacing, n_drops): # Count how many times the needle crosses a line crossings = 0 for _ in range(n_drops): # Random angle of needle with respect to lines angle = np.random.uniform(0, np.pi / 2) # Random distance from the center of the needle to the nearest line distance_to_line = np.random.uniform(0, line_spacing / 2) # Check if the needle crosses a line if distance_to_line <= (needle_length / 2) * np.sin(angle): crossings += 1 # Estimate pi using Buffon's Needle formula pi_estimate = (2 * needle_length * n_drops) / (crossings * line_spacing) return pi_estimate, crossings # --- Circle-based Monte Carlo Simulation --- n_points = 10000 # Number of random points for the Monte Carlo estimate pi_estimate, x, y, inside_circle = estimate_pi_circle(n_points) # Visualization for Circle-based Method plt.figure(figsize=(8, 8)) plt.scatter(x[inside_circle], y[inside_circle], color='blue', s=1, label='Inside Circle') plt.scatter(x[~inside_circle], y[~inside_circle], color='red', s=1, label='Outside Circle') plt.gca().set_aspect('equal', adjustable='box') plt.title(f'Estimate of Pi = {pi_estimate:.4f} using Monte Carlo (Circle Method)') plt.xlabel('x') plt.ylabel('y') plt.legend() plt.show() # --- Buffon's Needle Simulation --- needle_length = 1 # Length of the needle line_spacing = 2 # Distance between lines n_drops = 10000 # Number of needle drops pi_estimate_buffon, crossings = estimate_pi_buffon(needle_length, line_spacing, n_drops) # Display Buffon's Needle Estimate print(f\"Estimate of Pi using Buffon's Needle = {pi_estimate_buffon:.4f}\")","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}